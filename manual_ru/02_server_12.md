# Эволюция игрового фреймворка. Сервер 12. Репозиторий

## Команды

Задача любой программы — обработка данных. Данные находятся в оперативной памяти и являются состоянием программы. Сама же программа — это набор инструкций, сгруппированных в функциях и классах, которые изменяют это состояние необходимым нам образом.

Одна большая задача, которую решает программа, разбивается на множество задач поменьше, те еще на меньшие и так далее. Так, в зависимости от сложности решаемой задачи появляются модули, классы, функции. Отсюда вызов функции равносилен приказу: "Программа, сделай то-то". Всякий алгоритм состоит из последовательности таких приказов, то есть из последовательности вызовов функций.

Но когда приложение распределяется на несколько машин, а значит и на несколько программ — в данном случае на сервер и клиенты — мы уже не можем из одной программы напрямую вызвать функцию другой программы. Каждая программа запускается в своем адресном пространстве, а ОС просто так никому не даст к нему доступа. Это еще помимо множества других технических проблем вроде разного адресного пространства у разных программ.

Также, мы не можем сохранить все вызовы функций, чтобы потом можно было их воспроизвести в той же последовательности и посмотреть игру в повторе. При следующем запуске адреса функций и переменных могут оказаться совершенно другими, и все наши записи будут указывать не на те функции и данные.

Пусть повтор игры нам редко нужен, хотя и круто было бы его иметь. Но без сетевого режима в наше время обходится редкая игра. Поэтому для каждой задачи был придуман свой объект-команда, который легко можно сериализовать и передать по сети или сохранить в файл. Каждой команде ставится в соответствие некая функция, которая занимается выполнением той задачи, которую олицетворяет команда. Поиском нужной функции для команды занимается специальный движок. Он является сердцем приложения, команды — его кровью, а функции — мышцами и органами.

Все это описание того, что мы уже сделали. Но оно необходимо, чтобы лучше понять то, что мы собираемся еще сделать.

## Указатели на игровые объекты в командах

В полях объектов команд прописывается не только то, что нужно сделать, но и над какими объектами совершается действие. Например, если мы выбираем игру, в которую хотим зайти, нам нужно указать на объект игры, если мы в игре перемещаем объект на другую клетку, нам нужно указать на перемещаемый объект и координаты точки назначения и так далее.

Тут мы также не можем использовать прямые ссылки на реальные объекты, так как в одном приложении этот объект будет располагаться по одному адресу, а в другом — по другому. Поэтому каждому объекту присваивается идентификатор (id), который будет однозначно указывать на один и тот же объект везде, где он используется: и на клиенте, и на сервере, и в файле логов, и в команде во время передачи ее по сети.

Сейчас у нас используется для хранения состояния приложения обычный словарь (dict) storage. Ключ — это id, значение — игровой объект. Но если мы захотим использовать вложенные объекты, или обращаться к свойствам объектов напрямую по такой схеме ключа: "{id}.{property}", то нам понадобится обертка над словарем. Она будет, как и dict, иметь методы get, set, delete (в dict — pop), но ключ будет учитывать вложенность объектов:

```python
class Storage:
	def __init__(self):
		self.storage = {}

	def get(self, path):
		return resolve_path(self.storage, path)

	def set(self, path, value):
		...

	def update(self, path, value):
		...

	def delete(self, path):
		...

def resolve_path(target, path=None):
    if not path or target is None:
        return target
    current = target
    keys = path.split(".")
    for key in keys:
        if isinstance(current, dict):
            current = current.get(key)
        else:
            return None
    return current
```

## Хранилище (Storage/Repository)

Когда у нас есть собственный класс вместо стандартного, нам становится проще добавлять в него новые функции. Например, в прошлый раз мы в контроллере получали данные из файла с помощью сервиса, изменяли их и затем сохраняли обратно в файл.

Можно сделать подобную штуку в гораздо лучшем исполнении. Контроллер просто берет данные из хранилища и кладет их обратно в хранилище, и при этом его не заботит, откуда эти данные берутся на самом деле и куда потом помещаются: в файл ли, в БД, на другой ли удаленный сервер, или вообще никуда не помещаются, а просто хранятся в памяти. Все это скрыто от контроллера, и ему не нужно возиться с сервисами. Если в данном приложении нужно сохранять данные после каждого изменения в БД, то приложение стартует с одной имплементацией хранилища (например, DBStorage), если в файл — с другой (FileStorage) и т.д.

Более того, нам не нужно брать, как в том контроллере, данные каждый раз из файла. В методе get(), если объекта не существует, он будет взят из файла, а при всех последующих обращениях будет браться просто из памяти.

В результате класс Storage получается фасадом над абстрактным хранением данных. То как и где они хранятся на самом деле, как поддерживается их целостность и актуальность — все это скрыто от нас как от пользователей. Нас это не волнует — мы просто вызываем методы get, set, delete и все остальное делается так, как нужно системе, как она настроена изначально.

В DDD такой фасад для доступа к данным называется Repository, поэтому мы вполне можем использовать и это название вместо Storage.

## Выделение настроек из состояния

Во всяком приложении, в любом классе все переменные, все данные можно условно разделить на две основные категории: настройки (config) и состояние (state). Настройки предписывают функциям, как обрабатывать данный объект, состояние — это сам объект, набор текущих значений его свойств. Настройки, как правило, задаются перед использованием объекта и больше не меняются. Состояние тоже может устанавливаться перед использованием (начальное состояние), но изменяется всегда, когда с объектом что-то происходит. В этом его назначение — изменяться.

Все настройки приложения можно хранить в специальном файле (лучше всего для этого подходит формат YML) и загружать при его запуске. Начальные состояния объектов также можно хранить в настройках, откуда оно будет копироваться при создании объекта состояния. Так как настройки тесно связаны с состоянием, то их можно реализовать добавлением дополнительных функций в класс Repository. В приложении удобно использовать один объект и для получения настроек, и для получения состояния. В конце концов, и то и другое -- данные.

## Сохранение

Также в Repository можно добавить методы для сохранения и загрузки состояния. Это пригодится на случай, если нужно перезагрузить сервер с возможностью восстановить его работу. Так как файл настроек имеет свойство жить своей жизнью и меняться дизайнерами во время работы приложения, то если мы хотим возобновить работу с теми же конфигами, с которыми сервер стартовал изначально, вместе с состоянием нам нужно сохранить и старый конфиг. Например, под ключом "_config". Хранение настроек как переменной состояния -- это еще одно доказательство того, что настройки и состояние неразрывны.

## Хранилище как слой [#](#layers)

В общем, использование собственного класса Repository вместо стандартного dict дает нам множество возможностей управления данными без изменения кода его использования в контроллерах. Мы пишем контроллеры исходя из определенного интерфейса для получения и обновления данных. Интерфейс этот понятный и типичный для хранилища данных — get, set, delete — и он не меняется. Но реализацию его мы можем изменить в любой момент. Мы можем добавить автоматическую синхронизацию данных с базой данных (БД), и в контроллерах не изменится ни строчки.

Так в нашей структуре выделился новый слой — слой доступа к данным. Общую схему слоев можно представить таким образом:
1. Слой транспортировки сообщений - Server.
2. Слой форматирования сообщений - Parser.
3. Слой протокола приложения - ProtocolController.
4. Слой бизнес-логики - Controller.
5. Слой хранения данных - Repository.
6. Слой обработки данных - Model.
7. Слой доступа к внешним ресурсам - Service.

Преимущество слоев в том, что они независимы друг от друга. Один слой знает о другом только интерфейс, который тот предоставляет. Если интерфейс хорошо продуман, то он не будет изменяться. Поэтому все изменения внутри слоя -- внутри слоя и остаются. Более того, связи между слоями чаще всего однонаправленные. Это значит, что каждый слой знает только один соседний слой и не знает ничего об остальных. То есть если интерфейс его и изменится, то это затронет только единственного его соседа и никого больше.

Получается, что хорошо организованное приложение построено как идеальная подпольная организация. Конспирация должна быть на высшем уровне, чтобы вся система была устойчива к провалам и не рухнула при первом же ударе гестапо.

Вот такая вот у нас получилась система. До финальной готовности осталось только внести кое-какие усовершенствования в существующие классы. Чем и займемся дальше.

[Исходники](https://gitlab.com/markelov-alex/hx-py-framework-evolution/-/tree/main/f_models/server_socket/)

[< Назад](02_server_11.md)  |  [Начало](00_intro_01.md)  |  [Вперед >](02_server_13.md)
