# Эволюция игрового фреймворка. Сервер 1. Введение

Данное руководство задумывалось таким, чтобы можно было приступить к написанию игрового сервера, даже если выучил Python вот только недавно. Поэтому оно будет весьма подробным и обстоятельным. Надеюсь, это не сочтется за недостаток. Опытные разработчики могут прочитать уже известные места бегло, а начинающие будут не в претензии.

Раз мы договорились рассматривать все обстоятельно, вначале разберемся, что такое сервер и как он появился.

Резюме:
- Игра -> Разделение Single player — Multiplayer
- Multiplayer -> Разделение Local (Standalone) — Network
- Network -> Разделение Client — Server
- Server -> Разделение Listen Server — Dedicated Server

Игра -> Multiplayer -> Network -> Server -> Dedicated Server

А теперь подробнее.

В простейшем случае компьютерная игра представляет собой одну программу, которую пользователь запускает у себя на машине и потом играет сам с собой. А точнее, с самой программой и искусственным интеллектом (ИИ) ее персонажей — т.н. ботами. Но с ботами играть надоедает. Хочется поиграть с друзьями. Так появляется деление игр на однопользовательские (Single player) и многопользовательские (Multiplayer).

Простейший способ реализовать многопользовательский режим — это просто передавать ход (в пошаговых играх) не искусственному интеллекту, а обратно пользователю, подразумевая, что ходить будет другой игрок, сидящий рядом. Так можно сделать крестики-нолики, шашки и другие игры, где пользователи по очереди будут брать мышку (или можно подключить 2 USB-мышки, если есть) и делать ход, а компьютер, таким образом, будет просто заменять лист бумаги или игральную доску.

В случае, если нужно действовать одновременно, как, например, в платформерах, можно разделить клавиатуру на две части: один играет стрелочками, другой — WASD-клавишами.

Также есть игры, в которые не помещается весь игровой мир в один экран, и у каждого игрока должна быть своя видимая область (view port). Например, сюда относятся стратегии, гонки, шутеры. Тогда экран делится на равные части и каждый играет в своей области. Недостатки тут очевидны: маленькая область обзора и возможность подглядывать за действиями соперника. Внезапный хитрый рейд по тылам противника тут не совершишь.

Рано или поздно возникает идея: почему бы не играть в одну и ту же игру, но на разных компьютерах. Один из них будет основным — на котором выполняется логика игры, а другие будут получать и отправлять игровые данные по сети, но сами никакой логики содержать не будут. Основную машину назовем сервером (Server), т.е. тем кто служит ([to serve](https://www.etymonline.com/search?q=serve)), а остальные — ее клиентами (Client), т.е. тот кто следует, подчиняется (от лат. [clinare](https://www.etymonline.com/search?q=client) — кланяться). Иногда сервер также называют хозяином (Host), а клиенты — пирами (peer, от лат. [par](https://www.etymonline.com/search?q=peer) — равный).

Сервер хранит и обрабатывает текущее состояние игры, шлет все обновления клиентам. А те, в свою очередь, отправляют ему информацию о нажатии клавиш и других действиях пользователей.

Так появляется разделение на локальные (Local, или Standalone) и сетевые (Network) игры. Сетевое приложение при этом разбивается на две части: сервер и клиенты. Локальные игры можно рассматривать (и реализовывать!) как частный случай сетевых. Так как они объединяют в себе и логику, и отображение, то можно сказать, что Standalone-игры воплощают в себе одновременно и сервер, и клиент — являются "сетевой" игрой на одного локального игрока.

Описанная выше клиент-серверная модель, где один из клиент является одновременно и сервером, имеет один существенный недостаток — она не честная. Действия пользователя, играющего на серверном компьютере, поступают в игру мгновенно, тогда как для остальных клиентов добавляется сетевая задержка. Сервер является общим арбитром для клиентов — обычно в каком порядке туда пришли сообщения, в таком они и считаются системой. Это дает некоторое преимущество в реагировании на события игры, а, значит, и на ее исход. Также игрок может взломать игру и управлять сервером по своему усмотрению, в то время как клиенты на логику никак влиять не могут по определению. Они только отображают данные с сервера на своем экране и посылают состояние устройств ввода в обратном направлении.

Чтобы ликвидировать этот недостаток нужно сделать всех игроков равнозначными клиентами. Сервер в таком случае обособляется и выносится на отдельную машину, к которой игроки не имеют доступа. Так появляется различение серверов на те, которые создаются пользователями (Listen Server), и на выделенные серверы (Dedicated Server), от пользователей не зависящие. Для большинства игр поддержкой выделенных серверов занимаются создатели игры. В некоторых случаях, если есть доступ к программе сервера (доступ может быть платный или бесплатный), выделенные игровые сервера могут создавать и другие компании или организации, вплоть до обычных пользователей локальной сети. Тут уже игрокам нужно смотреть на авторитетность и честность такого организатора, чтобы быть уверенным, что серверы не будут взломанны (умышленно или неумышленно).

Итак, мы проследили все этапы логического развития игрового приложения от первоначальной Standalone-версии через Listen Server до Dedicated Server. Эти же этапы игры проходили и исторически: сначала появлялись игры, где нужно было соревноваться с алгоритмом, потом добавляли возможность использования дополнительных устройств ввода за одним компьютером или приставкой (несколько джойстиков, разделение клавиатуры), далее игра по локальной сети на разных машинах и, наконец, чисто сетевые игры с логикой на выделенном сервере. Как и везде, тут логическое развитие совпадает с историческим.

Все описанные выше модели вплоть до Listen Server, включительно, подразумевают написание и выполнение одной программы, которая в некоторых случаях может иногда работать как сервер. Но по сути он остается клиентом и разрабатывается как клиент, а потому здесь рассматриваться не будет. Создание клиента нами разобрано [выше](01_client_01.md). Напротив, выделенный сервер содержит только чистую логику, т.е. работу исключительно с данными, а не отображением. Поэтому он может разрабатываться на любом другом языке программирования. Если клиентские программы должны запускаться на самых разнообразных пользовательских машинах и операционных системах (ОС) и их версиях, то для сервера мы сами выбираем конфигурацию системы, и ограничений по языкам программирования не существует.

В виду этого мы можем себе позволить разрабатывать сервер на Python, хоть этот язык редко не используется в разработке Standalone-игр и клиентов. Разве что для скриптования логики в больших играх. Для остальных он слишком медленный в выполнении из-за того, что он интерпретируемый и динамический. Но эти же качества языка делают разработку на нем более быстрой благодаря, в частности, тому, что не нужно декларировать тип для каждой переменной и компилировать всю программу перед каждым запуском. К тому же сам процесс написания кода на Python гораздо приятнее в силу удобного синтаксиса и организации программ, а код получается кратким и выразительным.

В случае же, когда развитие проекта потребует высокой скорости исполнения программы, код можно немного изменить, добавив в него явную типизацию, чтобы его можно было компилировать в Cython. Код Cython преобразуется в код C/C++, который можно компилировать в обычное исполняемое приложение. В Cython удобства синтаксиса Python совмещаются со скоростью C/C++.

Для тех, кто плохо знаком с Python, рекомендую пройти бесплатный и очень неплохой туториал [pythontutor.ru](https://pythontutor.ru/). В нем можно опробовать и запускать все примеры прямо из браузера. Для более сложных вещей, которые не вошли в курс, вам понадобится только официальная документация на [docs.python.org](https://docs.python.org/3/), которая также написана максимально кратко и понятно.

Также максимально кратко и в то же время подробно, без пропуска промежуточных этапов, составлено данное руководство по написанию игрового сервера. Так что к нему можно приступить сразу после [pythontutor.ru](https://pythontutor.ru/), а все непонятные места уточнять в [docs.python.org](https://docs.python.org/3/).

Быстрее и лучше всего освоить любой предмет можно, только если он действительно интересен, а материал вводится постепенно. Вот почему сразу после [pythontutor.ru](https://pythontutor.ru/) можно сразу приступить к данному руководству. На нем можно проследить полную эволюцию игры от примитивной поделки до универсального профессионального фреймворка, позволяющего создавать игры любого уровня сложности.

Подробнее:
Глейзер Дж., Мадхав С. — Многопользовательские игры. Разработка сетевых приложений
[Как устроен мультиплеер - подробно | Networking (Cyberstars)](https://www.youtube.com/watch?v=0LxyqYV86Fk)

[Исходники](https://gitlab.com/markelov-alex/hx-py-framework-evolution/-/tree/main/f_models/)

[< Назад](01_client_22.md)  |  [Начало](00_intro_01.md)  |  [Вперед >](02_server_02.md)
