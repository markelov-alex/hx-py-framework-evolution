# Эволюция игрового фреймворка. Сервер 15. HTTP-сервер

До этого момента мы рассматривали самый общий, и потому самый сложный случай — разработку мультиплеерных онлайн игр. Так как действие одного пользователя должно немедленно доводится до остальных, то за основу реализации брался сокет-сервер. Только он позволяет серверу самому инициировать отправку сообщений клиенту.

Но не все онлайн игры мультиплеерные, и не все игры — онлайн. Для одиночных онлайн игр (вроде ферм, слотов, match-3) подойдет и HTTP-сервер. Такой сервер чаще всего применяется разработчиками игр, а потому его хостинг может оказаться дешевле и более простым в обслуживании. Некоторые хостинг-провайдеры вообще предоставляют ограниченный бесплатный доступ к своим серверам, так что можно стартовать и опробовать свое приложение вообще без вложений.

Итак, если нам нужно выбирать: сокет-сервер или HTTP-сервер, то мы, главным делом, смотрим, мультиплеерная у нас игра или одиночная. Если мультиплеерная, то без сокетов вряд ли обойдемся, если одиночная, то проще выбрать HTTP.

[Ранее](02_server_12.md#layers) мы приводили схему разбивки нашей системы на слои:
1. Слой транспортировки сообщений - Server.
2. Слой форматирования сообщений - Parser.
3. Слой протокола приложения - ProtocolController.
4. Слой бизнес-логики - Controller.
5. Слой хранения данных - Repository.
6. Слой обработки данных - Model.
7. Слой доступа к внешним ресурсам - Service.

Теперь посмотрим, какие слои предстоит заменить для переноса приложения на HTTP.

## Сервер (слой 1)

HTTP-сервер — это тоже сокет-сервер, но с тем отличием, что соединение разрывается сразу после отправки первого же ответного сообщения. Алгоритм его работы такой: сокет-соединение устанавливается, принимается запрос от клиента, он обрабатывается, и отсылается ответное сообщение на клиент. В конце каждой отправки соединение тут же закрывается.

И еще HTTP — протокол стандартный и широкоизвестный. Поэтому существует множество реализаций такого типа серверов, в том числе и на Python: Django, Twisted, Tornado. Мы выберем один из самых популярных и минималистичных — Flask. Помимо получения и отправки сообщений, одной из основных задач таких фреймворков является преобразование HTTP-запросов (чаще всего GET и POST) из текстового вида в специальный объект request и созданный нами объект response обратно в текстовый вид.

## Парсер (слой 2)

С первым слоем разобрались. За транспортировку сообщений (слой 1) будет отвечать один из популярных HTTP-фреймворков. В нашем примере это будет Flask. Далее нужно обеспечить преобразование объектов запросов, которые использует Flask, в привычные для нашего приложения команды. Это ответственность классов второго слоя — слоя форматирования сообщений. Для этого создадим класс FlaskParser, который будет преобразовывать объекты Flask в привычные нам команды и обратно.

## Хранилище (слой 5) (?)

В силу того, что соединение создается только на один запрос, и скрипт при этом сразу завершается, становится невозможно хранить состояние приложения непрерывно в памяти. Перед обработкой каждого запроса состояние должно вновь и вновь создаваться заново (или воссоздаваться из файла или БД), потому что после отправки ответа оно будет вновь уничтожено. Поэтому тут нужна своя версия хранилища-репозитория, которая будет загружать нужные данные из нужного места (в нашем примере — HTTPRepository).

## Результат

Итого, изменениям подверглось три слоя: сервер, парсер и репозиторий. А также для их общей увязки создается новый движок — FlaskApplication. Код, относящийся к Flask, представляет собой объект самого HTTP-сервера (`app = Flask(__name__)`) и по одной функции-обработчику на каждый элемент API (помечается декоратором `@app.route()`):

```python
import json
from flask import Flask, send_file, request

app = Flask(__name__)
application = FlaskApplication(FlaskParser(), MyController())

@app.route("/storage/<key>")
def storage(key):
    return application.handle_request(key, request)
```

Сами же новые части нашего фреймворка могут выглядеть примерно так:

```python
class FlaskApplication:
    def __init__(self, parser, default_controller, controller_by_key=None):
        super().__init__()
        self.parser = parser
        self.default_controller = default_controller
        self.controller_by_key = controller_by_key or {}
        self.storage = HTTPRepository()

    def handle_request(self, key, request):
        # Parse
        command, _ = self.parser.parse(request)
        # Handle
        controller = self.controller_by_key.get(key, self.default_controller)
        index, result = "xxx", []
        controller.handle_command(self.storage, index, command, result)
        # Get response
        response = []
        for indexes, commands in result:
            if "xxx" in indexes:
                response.extend(commands)
        # Response
        return self.parser.serialize(response[0] if len(response) == 1 else response)

class FlaskParser(Parser):
    command_by_alias = {
        "GET": "get",
        "POST": "save",
        "PATCH": "update",
    }

    def parse(self, request):
    	# Parse
        values = request.values
        data_str = values.get("data")
        data = json.loads(data_str) if data_str else None
        if data is None:
            data = {}
        # Prepare command
        code = data.get("code")
        if not code:
            code = values.get("_method") or request.method
        data["code"] = self.command_by_alias.get(code, code)
        data["key"] = request.view_args.get("key")
        return data, b""

    # No real serialization needed here
    def serialize(self, command):
        return command

class HTTPRepository:
	...
```

Исключительно важно, что все три измененных слоя относятся только к фреймворку, а значит, что вся наша кастомная логика (контроллеры, модели, сервисы) остается неизменной и может использоваться как есть. Поэтому, если кто-то решает для себя вопрос: HTTP или сокеты, то для нас он уже решен: и HTTP, и сокеты.

А что касается игр, которые не онлайн, то для них вообще сервер не нужен. А если нет сервера, то автоматически отпадает и парсер. Одиночная игра — частный случай сетевой. Поэтому, если логика написана хорошо, то она вполне может быть успешно использована для любого режима игры (если клиент также использует Python).

А построение архитектуры игры на командах позволит нам записывать течение игры для ее воспроизведения или на случай отладки. Также это позволяет на клиенте полностью разнести программно визуальную составляющую и логику. То есть первым делом строится GUI на командах, а логика может быть потом реализована или на клиенте (для одиночной игры), или на сервере (для онлайн игр).

Напоследок заметим, что [исходный код](https://gitlab.com/markelov-alex/hx-py-framework-evolution) писался в противоположном порядке, чем данное руководство, и это нужно учитывать. Сначала разрабатывался HTTP-сервер, и только потом — сокет-сервер. Тогда как по тексту наоборот. Поэтому некоторые вещи в сокет-сервере могут отсутствовать в HTTP-версии или казаться немного недоработанными. Но я решил оставить как есть, на случай, если кому-нибудь будет интересно проследить альтернативную версию эволюции фреймворка.

## Что дальше

Итак, мы разобрались как в Python создается [сокет-сервер](02_server_08.md), как все возможные способы отличаются друг от друга и каким пользоваться лучше всего и почему. Затем мы на основании сервера построили [фреймворк](02_server_09.md), который задает структуру всякого приложения и обеспечивает всю необходимую инфраструктуру для его работы. В результате создание приложения теперь сводится только к написанию чистой логики в контроллерах и моделях — все остальное обеспечивает фреймворк.

Приступая к новому жанру игры, нам прежде всего предстоит проанализировать и систематизировать предметную область, построить ее модель. В случае игр это означает классифицировать все жанры, выявить в них общее и различия, выстроить в единый ряд — от простого к сложному. Далее, модель начинает формализоваться и материализоваться в виде кода. Сначала создается формат данных, подбираются наиболее точные и общие понятия, названия объектов и их свойств. Потом создаются функции, занимающиеся сугубо обработкой этих данных, объекты которых передаются в них в виде параметров. Эти функции группируются по назначению в классах моделей. И в конце для каждой игры создаются контроллеры, которые реализуют бизнес-логику игры, ее правила. Контроллеры не занимаются напрямую обработкой данных, а делают это только через модели. Разнообразные обращения к внешним ресурсам через сервисы также осуществляют контроллеры.

Мы не будем создавать весь код моделей и контроллеров для игр, а только опишем в общих чертах, как это, по нашему мнению, следует (или можно было бы — кому как нравится) сделать. (По сути продолжение руководства должно создаваться как теория разработки игр. А предыдущие разделы — разработка клиентского и серверного фреймворка — практика разработки игр, тот контекст и основа, которые будут использоваться при рассмотрении теоретических вопросов.)(?)

[Исходники](https://gitlab.com/markelov-alex/hx-py-framework-evolution/-/tree/main/f_models/server_flask/)

[< Назад](02_server_14.md)  |  [Начало](00_intro_01.md)  |  Вперед >
