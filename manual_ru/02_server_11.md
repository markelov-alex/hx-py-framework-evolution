# Эволюция игрового фреймворка. Сервер 11. Внутреннее устройство контроллеров

## Выделение модели и сервисов из контроллера. Протокол приложения

К этому моменту мы [получили](02_server_10.md) уже вполне оформившийся фреймворк, состоящий из сервера, парсера, движка приложения и интерфейса для контроллеров. Дальше мы будем только улучшать и углублять то, что получилось.

Фреймворк забирает у нас всю рутинную работу и оставляет одну только логику, представленную контроллерами. В будущем каждое наше приложение будет просто набором из нескольких контроллеров. Они обрабатывают команды, изменяют состояние приложения (storage) и возвращают другие команды, чтобы сервер их отослал нужным клиентам. Все остальное берет на себя фреймворк.

Очевидно, что если помещать всю логику в один класс, то это в большинстве случаев окажется большой класс. Большой класс — это много кода. А много кода, собранного в одном месте — это мешанина. Поэтому нужно определиться, как мы будем организовывать код контроллеров. Этим мы и займемся в данном материале.

## Отделение сервиса

В самом начале мы для примера реализовали три команды: get, set, update, которые напрямую управляли состоянием приложения, которое хранилось в памяти. Возьмем в качестве примера ту же задачу, но теперь будем хранить данные не в памяти, а в файле. Это самый простой способ эмулировать работу реального приложения с базами данных (БД).

```python
class MyController:
	def handle_command(self, storage, i, command, result_self, result_all):
		key = command.get("key")
		key = escape(key)  # Never trust data from users
		filename = "../data/save_" + key
		dirname = os.path.dirname(filename)
		if not os.path.exists(dirname):
			os.makedirs(dirname)
		code = command.get("code")
		if code == "save" or code == "set":
			state = command.get("state")
			with open(filename, "w") as f:
				json.dump(state, f)
				f.flush()
			result_self.append({"success": True, **command})
		elif code == "load" or code == "get":
			if not os.path.exists(filename):
				return {"success": False, **command}, None
			with open(filename, "r") as f:
				state = json.load(f)
			result_self.append({"success": True, **command, "state": state})
		elif code == "update":
			index = command.get("index")
			value = command.get("value")
			if not isinstance(index, int) or not isinstance(value, int):
				result_self.append({"success": False, **command})
				return
			if not os.path.exists(filename):
				state = []
			else:
				with open(filename, "r") as f:
					state = json.load(f)
			if index >= len(state):
				state += [0] * (index - len(state) + 1)
			state[index] = value
			with open(filename, "w") as f:
				json.dump(state, f)
				f.flush()
			result_all.append({"success": True, **command})

def escape(string):
    return re.sub(r"[^A-Za-z]+", "", string)
```

Как мы и говорили — мешанина. Давайте вычленим отсюда отдельные примеси, которые можно объединить по некоему общему признаку и выделить в отдельный класс. Прежде всего можно вынести работу с файлами. Поскольку работа с файлами — функция служебная и чисто техническая, то есть не содержащая бизнес-логики, то назовем данный тип классов службами (Service), а нашу реализацию с файлами — FileService.

```python
class StorageService:
    def save(self, key, data):
        pass

    def load(self, key):
        return None

class FileService(StorageService):
    filename_prefix = ""

    def __init__(self, filename_prefix=None):
        self.filename_prefix = filename_prefix or self.filename_prefix

    def save(self, key, data):
		key = escape(key)  # Never trust data from users
        filename = self.filename_prefix + key
        dirname = os.path.dirname(filename)
        if dirname and not os.path.exists(dirname):
            os.makedirs(dirname)
        with open(filename, "w") as f:
            json.dump(data, f)
            f.flush()
            print("save", data)

    def load(self, key):
		key = escape(key)  # Never trust data from users
        filename = self.filename_prefix + key
        if not os.path.exists(filename):
            return None
        with open(filename, "r") as f:
            data = json.load(f)
            print("load", data)
            return data

class MyController:
    # Settings
    service_factory = lambda self: FileService("../data/save_")
    model_factory = lambda self, *args: MyModel(*args)

    def __init__(self):
        self.service = self.service_factory()
        self.model = self.model_factory(self.service)

    def handle_command(self, storage, i, command, result_self, result_all):
        code = command.get("code")
        key = command.get("key")
        if code == "save" or code == "set":
            state = command.get("state")
            success = self.service.save(key, state)
            result_all.append({**command, "success": success})
        elif code == "load" or code == "get":
            state = self.service.load(key)
            result_self.append({**command, "success": True, "state": state})
        elif code == "update":
            index = command.get("index")
            value = command.get("value")
            state = self.service.load(key)
			if not isinstance(index, int) or not isinstance(value, int):
				success = False
			else:
				if state is None:
					state = []
				if index >= len(state):
					state += [0] * (index - len(state) + 1)
				state[index] = value
				success = True
            self.service.save(key, state)
            result_all.append({**command, "success": success})
```

Посмотрите на `handle_command()`: насколько сразу легче стало дышать! Но выгода не только в этом. Теперь весь функционал по сохранению и загрузки из файла собран в одном месте. А это значит, что нам теперь не нужно рыскать по коду, если нужно сменить имя файла или сохраняемый формат с JSON на YML, например. Достаточно найти соответствующий класс.

Более того. Мы можем реализовать в другом классе тот же интерфейс, но уже не сохранять в файл, а пересылать данные на удаленный сервер (например, через HTTP-запрос) или помещать их в базе данных (БД). Ведь контроллеру все равно, как сервис выполнит свою задачу — он лишь вызывает метод load() или save(). С точки зрения логики (контроллера), не нужно сохранить данные именно в файл. Нужно просто сохранить данные. И не нужно загрузить данные обязательно только из файла. Данные просто нужны, и поэтому их нужно загрузить — все равно откуда.

Поэтому отдельно вынесен интерфейс StorageService, который из-за ["утиной" типизации](https://ru.wikipedia.org/wiki/%D0%A3%D1%82%D0%B8%D0%BD%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) Python носит скорее информативную нагрузку, чем реальную пользу. Утиная типизация означает, что классы могут просто реализовывать определенный набор методов с определенными параметрами, и они будут успешно использованы в коде, даже если эти классы не имеют ни одного общего предка или интерфейса. Класс StorageService просто говорит программистам, что есть такой тип сервисов, предназначенный для решения вот такой задачи, и вы можете придумать свою особую реализацию данной задачи.

## Отделение модели

Вторая категория функций, которые реализуют контроллеры — это обработка данных. Этот функционал также можно успешно вынести из контроллеров в отдельные классы, которые называются моделями.

Почему модели? Всякое приложение отражает ту или иную область деятельности человека из реальной жизни, которая называется предметной областью приложения. Но реальность нам не нужна во всей ее полноте. Нам нужны только те существенные ее стороны, которые помогают решить поставленную задачу. Эти грани реальности формализуются, параметризуются, и в результате на их основе строится модель. В модель, в узком смысле, входят параметры настроек, информация о текущем состоянии и алгоритмы обработки этих данных. В широком смысле модель — это вообще все приложение.

Объект storage просто хранит абстрактные данные, и он абсолютно одинаковый для всех предметных областей. Поэтому storage не является моделью. Хотя данные и объекты, которые относятся к модели, и хранятся в нем.

Данные модели — это обычные абстрактные JSON-объекты (словари и списки), и определенную осмысленную форму они приобретают только в функциях обработки данных. То есть только в при обработке просто данные становятся данными модели. Получается, в этих функциях воплощены оба аспекта модели: и данные (точнее, их формат: имена и типы), и алгоритмы обработки данных. Вот почему, классы, в которых они группируются, и называются моделями (Model).

В данном примере обработки данных не много — хватило лишь на один метод. Но для иллюстрации принципа вполне достаточно и этого:

```python
class MyModel:
    def update(self, state, index, value):
        if not isinstance(index, int) or not isinstance(value, int):
            return False
        if state is None:
            state = []
        if index >= len(state):
            state += [0] * (index - len(state) + 1)
        state[index] = value
        return True

class MyController:
    # Settings
    service_factory = lambda self: FileService("../data/save_")
    model_factory = lambda self, *args: MyModel(*args)

    def __init__(self):
        self.service = self.service_factory()
        self.model = self.model_factory(self.service)

    def handle_command(self, storage, i, command, result_self, result_all):
        code = command.get("code")
        key = command.get("key")
        if code == "save" or code == "set":
            state = command.get("state")
            success = self.service.save(key, state)
            result_all.append({**command, "success": success})
        elif code == "load" or code == "get":
            state = self.service.load(key)
            result_self.append({**command, "success": True, "state": state})
        elif code == "update":
            index = command.get("index")
            value = command.get("value")
            state = self.service.load(key)
            success = self.model.update(state, index, value)
            self.service.save(key, state)
            result_all.append({**command, "success": success})
```

Использование классов модели дает нам все те же преимущества, что мы описывали раньше:
 - возможность подставлять разные реализации одного и того же интерфейса и тем менять детали функционала, не меняя основной структуры кода,
 - возможность наследовать старый код, переопределяя части функционала.

## Изменившаяся роль контроллера

Если посмотреть внимательнее на получившийся контроллер, то можно увидеть, что в нем фактически не осталось логики в чистом виде. Одни вызовы методов. Все свои функции контроллер делегировал двум большим категориям классов: моделям и сервисам. Себе же он оставил функции диспетчера между состоянием (storage), моделями (model) и сервисами (service). Диспетчера и обработчика команд (command).

Контроллер смотрит на имя команды и переходит к соответствующему блоку кода для ее обработки. Далее из объекта команды достаются переменные, а из storage запрашиваются нужные объекты состояния. Затем все вместе они передаются в виде аргументов моделям и сервисам.

Последние оперируют только с теми объектами состояния, которые ему действительно необходимы. Все состояние приложения обычно не передается в модель или сервис, чтобы они сами выбрали, что им нужно. Это не их дело — ни модель, ни сервис не должны знать о структуре объектов состояния. Об этом должен знать только контроллер. Таким образом, контроллер занимается всей подготовкой и подбором данных для моделей и сервисов, а также координацией их совместной работы.

## Протокол

Кроме того, он еще отвечает за обработку результатов и подготовку ответных команд клиентам. Тем самым на его долю выпадает вся работа с командами. Фактически контроллер — единственный, кто знает формат команд. Сервер оперирует просто потоком байтов, парсер — преобразует его в абстрактные JSON-объекты и обратно, Application знает ровно столько, чтобы подобрать подходящий контроллер. Но тип команды, операция, которую она выполняет, параметры этой операции и их назначение — все это известно лишь контроллеру. Модели и сервисы получают их уже в виде параметров своих функций — они тоже не знают ничего о командах.

Таким образом, контроллер — это еще и протокол приложения. То есть тот формат команд, который используется сервером и который должен возвращать парсер. Клиенты могут использовать разный формат данных — XML, JSON или YML, но парсер всегда должен возвращать питоновские dict и list, как после обыкновенного JSON. Клиенты могут использовать разные имена и значения параметров, разные коды команд, но парсер должен всегда возвращать те имена, значения и коды, которые приняты у нас на сервере, которые понимают контроллеры. Это то, что и называется протоколом приложения. И он используется нигде больше, кроме как в контроллерах.

Получается, что один класс контроллера реализует сразу две функции: протокола приложения и диспетчера. А у нас уже сформировалось такое правило: если в классе обнаруживается два функционала, мы делаем два класса. Или, другими словами: ~~ein Reich — ein F...~~ один класс — одна функция, одно назначение.

Устраним этот недостаток. Создадим отдельно:
1. протокольный контроллер, который отвечает только за разбор команд, и
2. функциональный контроллер, который работает с моделями, сервисами и состоянием и наследуется от протокольного.

При этом, если первый является шаблоном контроллера, то второй — его конкретной реализацией:

```python
class MyProtocolController:
    def handle_command(self, storage, index, command, result_self, result_all):
        code = command.get("code")
        key = command.get("key")
        all_indexes = storage.get("indexes")
        if code == "save" or code == "set":
            state = command.get("state")
            success = self.save(key, state)
			result_all.append({**command, "success": success})
        elif code == "load" or code == "get":
        	state = self.load(key)
			result_self.append({**command, "success": True, "state": state})
        elif code == "update":
            index = command.get("index")
            value = command.get("value")
            self.update(key, index, value, command, result_self, result_all)

    def save(self, key, state):
		pass

    def load(self, key):
		pass

    def update(self, key, index, value, command, result_self, result_all):
    	pass

class MyController(MyProtocolController):
    # Settings
    service_factory = lambda self: FileService("../data/save_")
    model_factory = lambda self, *args: MyModel(*args)

    def __init__(self):
        self.service = self.service_factory()
        self.model = self.model_factory(self.service)

    def save(self, key, state):
		success = self.service.save(key, state)
		return success

    def load(self, key):
		state = self.service.load(key)
		return state

    def update(self, key, index, value, command, result_self, result_all):
		state = await self.service.load(key)
		success = self.model.update(state, index, value)
		if success:
			success = self.service.save(key, state)
		result_all.append({**command, "success": success})
```

Правда, для удобства информация о командах может иногда проникать в реализацию контроллера. Это допускается в некоторых особенно сложных случаях, например, если генерируется несколько ответных команд, каждую из которых нужно рассылать особому адресату. И хоть у нас пока случай далеко не такой, но мы все равно реализовали одну функцию в этом ключе — для примера (update()).

Заметим, что использование сервисов подразумевает значительные задержки ввода-вывода, а это значит, что чтобы выполнение программы не останавливалось, все методы сервисов должны быть асинхронными (async). Проставление перед всеми методами ключевого слова async, а перед каждым вызовом — await остается для самостоятельной работы.

## Переход к DDD-разработке

Вот так, почти что в [DDD-стиле](https://www.youtube.com/watch?v=rkQ3-T82pkU) мы организовали разработку логики приложения. Мы выяснили:
1. что общая логика реализуется в контроллерах,
2. логика обработки данных поручается моделям,
3. служебные функции по работе с внешними ресурсами — сервисам,
4. протокол приложения выделяется в отдельный контроллер-шаблон протокола,
5. конечная реализация контроллера наследуется от протокольного и в основном обеспечивает взаимодействие между состоянием, моделью и сервисами, т.е. выполняет функции диспетчера между всеми этими компонентами.

Разработку тоже можно вести в DDD-стиле. Сначала вникаем в предметную область, создаем терминологию и вообще язык этой предметной области. Язык (имеется в виду прежде всего терминология) должен быть общим для программистов и для тех, кто непосредственно работает в этой предметной области. Все имена и выражения в программе также должны использовать этот язык.

Вникнув в предмет, мы переходим к его моделированию. Берем существенное и отделяем его от всего второстепенного и случайного. Существенное — это то, без чего предмет перестает быть тем, чем он является, то есть становится другим предметом.

Получив в голове более-менее определенную картину о предмете — модель этого предмета, приступаем к программированию. Начинаем с данных. Определяем, какие типы объектов мы будем использовать, как они друг с другом соотносятся, какую структуру и иерархию они образуют, из каких свойств состоят: имена, типы.

Далее переходим к классам моделей. Для каждого действия и операции, предусмотренными нашим представлением о предмете, создаем метод. В общем, пишем код по обработке данных.

После этого приступаем к реализации функций контроллера, которые во многом будут повторять функции модели. Где надо, делаем сервисы.

Так, постепенно поднимаясь все выше и выше, доходим до реализации протокола в протокольном контроллере. Этот протокол в последствии уходит разработчикам клиента.

Или наоборот, клиентщики дают протокол, а мы под него пишем серверную часть приложения, проходя все выше описанные этапы, но уже в обратном порядке. Хотя на практике, скорее всего вы будете работать сообща и постепенно — от итерации к итерации добавлять новые функции и совершенствовать уже сделанные одновременно и на клиенте, и на сервере.

[Исходники](https://gitlab.com/markelov-alex/hx-py-framework-evolution/-/tree/main/f_models/server_flask/)

[< Назад](02_server_10.md)  |  [Начало](00_intro_01.md)  |  [Вперед >](02_server_12.md)
